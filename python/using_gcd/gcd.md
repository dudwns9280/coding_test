
## 최대 공약수와 최소 공배수
기본이 되지만 놓치기 쉬운 알고리즘  
제대로 안챙기면 이걸 활용하는 문제에서 시간 초과가....!!

### 모든 공약수 구하기
get_gcd_list.py

공약수란 ?  
두 수를 곱해서 number가 나오는 수가 공약수이다.    
n이 주어질 때 n의 모든 공약수 리스트를 얻는 방식은 총 3가지임.  
1번 방식: n까지 for루프를 다 돌며 O(n)이 걸리는 방법.
- get_cd_list_using_1 함수로 구현.
- 나머지가 0이 되는 수를 찾아서 list에 append

2번 방식 : 공약수는 무조건 짝이 있기에 n만큼이 아닌 n의 절반만큼만 for 루프를 돌린다.
- get_cd_list_using_2 함수로 구현.
- 나머지가 0이되는 수를 찾고 해당 수로 n을 나눈 나머지값과 해당 값을 list에 append


2번 방식 : 제곱근을 활용한 방식
- get_cd_list_using_3로 구현
- 생각을 해보면 16의 공약수는 1,2,4,8,16이다.
- 여기서 중요한것은 4까지만 돌면 공약수를 다 찾아낼 수 있다는 것이다.
- 다른 수로 예를 들자면 20의 공약수는 1,2,4,5,10,20이다.
- 여기서 또한 4까지만 돌면 문제 없이 가능하다.
- √20의 경우 4.472이다.
- 루프에 +1을 해주는 이유는 range로 for문을 돌릴땐 stop의 마지막 수는 포함이 안되기 때문
- 만약 제곱근의 값이 4.4라면 int로 인해 4가 될것이고, 그러면 4는 루프가 안돌기 때문에 +1을 해주는 것이다

100000까지 공약수 구할 때 걸린 시간 측정.  
1번 방법 :  0.00653 ms  
2번 방법 :  0.002772 ms  
3번 방법 :  0.000041 ms


### 최대 공약수

개념 : 두 수 사이의 최대 공약수는 유클리드 호제법을 사용하여 구한다.

유클리드 호제법의 원리
- 두 수 a, b가 있을 때 두 수를 나눈 나머지를 c라고 한다
- a와 b의 최대 공약수는 b와 c의 최대 공약수와 같다.
- 즉, a와 b의 최대공약수나 b와 c의 최대 공약수나 같으니 a를 b로 나눈 값과 b만 남기는 행위를 계속적으로 반복하다보면 최대공약수에 다다를 수 있다는 것이다.

자세한 내용은 위키를 참고하자( 설명이 너무 깔끔하다 )

하지만 유클리드 호제법에는 a > b 라는 규칙이 있다!!

[https://ko.wikipedia.org/wiki/유클리드_호제법](https://ko.wikipedia.org/wiki/%EC%9C%A0%ED%81%B4%EB%A6%AC%EB%93%9C_%ED%98%B8%EC%A0%9C%EB%B2%95)

실제 코드로 구현했을 때 a>b라는 규칙은 존재하지 않는다.  
왜냐하면 a가 50, b 가 150이라는 숫자가 들어왔다고 가정하자.  
첫 루프에서 a = 150이 될것이고, b = 50 %150이니 50이 될것이다.  
따라서 %기능을 통해 b의 값이 더 크면 자연스레 a와 b의 값이 스위칭되는 현상을 볼 수 있다!  
시간 복잡도는 O(logN)의 시간이 걸림.

### list에 담긴 숫자들의 최대 공약수

- 두 수의 최대 공약수와 새로운 수를 비교하여 최대 공약수를 구하고,
- 해당 최대 공약수와 새로운 수의 공약수를 구해나가는것을 반복하는 행위이다.

### 최소 공배수

개념 : 공배수들 중 제일 작은 공배수.
- 최대 공약수를 구할 수 있다면 엄청 쉽게 구할 수 있음.
- 두 수 m,n이 있다고 가정하면
- m * n = 최대 공약수 * 최소 공배수
- 따라서 LCM = m * n / 최대 공약수 가 된다.

### 분수 덧셈
분자와 분모를 각각 입력 받아 분수끼리 더하는 방법
- 통분을 하여 더한다고 가정한다.
- 분모를 서로 곱하면 분모는 통분 완료.
- 분자는 상대 분모를 분자에 곱하여 2개를 합친다.
- 통분된 분모와 분자가 나왔는데 약분을 해줘야 한다.
- 최대한 약분을 할 수 있는 방법은 통분된 분모와 분자의 최대 공약수로 약분을 한다.